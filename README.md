# TFG_Compiler

ğŸ“Œ Overview

This repository contains my Bachelorâ€™s Thesis (TFG) project, focused on the design and implementation of a compiler.
The project explores the main stages of compilation, from source code processing to code generation, with an emphasis on software architecture, correctness, and system-level reasoning.

The goal of this project was to apply theoretical computer science concepts in a practical and structured software engineering context, building a working compiler pipeline.

ğŸ§  Project Objectives

Design and implement a complete compilation pipeline

Apply formal language and compiler theory to real code

Build modular and maintainable components

Strengthen system-level and abstraction skills

âš™ï¸ Compiler Structure

The project is organized around the classical compiler phases:

Lexical Analysis â€“ tokenization of source code

Syntax Analysis â€“ parsing and grammar validation

Semantic Analysis â€“ symbol management and semantic checks

Intermediate Representation â€“ structured internal model

Code Generation â€“ target code emission

Each phase is implemented as a clearly separated module, enabling easier reasoning, testing, and extension.

ğŸ› ï¸ Technologies & Concepts

Programming Languages: C / Java / Python (adapt as needed)

Parsing techniques (top-down / bottom-up)

Abstract Syntax Trees (AST)

Symbol Tables

Compiler design patterns

Modular software architecture

(Tip: only list what you actually used â€” accuracy > quantity)

ğŸ“ Repository Structure
TFG_Compiler/
â”œâ”€â”€ lexer/
â”œâ”€â”€ parser/
â”œâ”€â”€ semantic/
â”œâ”€â”€ codegen/
â”œâ”€â”€ tests/
â””â”€â”€ docs/


(Adjust folders to match your real structure)

ğŸš€ How to Run
# Example
make
./compiler input_file


(If execution is complex, itâ€™s OK to keep this minimal or add â€œsee docs/â€)

ğŸ“ Academic Context

This project was developed as part of the Bachelorâ€™s Degree in Computer Engineering
at Universitat Pompeu Fabra (UPF), Barcelona.

ğŸ“ˆ What This Project Demonstrates

Strong software engineering fundamentals

Ability to reason about complex systems

Practical application of theoretical CS concepts

Clean code organization and modular design

Debugging and correctness-oriented development

ğŸ“Œ Future Improvements

Optimization passes

Extended language features

Improved error handling

Additional target architectures

ğŸ‘¤ Author

Pau Alcaide Canet
Computer Engineering Graduate
LinkedIn
 Â· GitHub
